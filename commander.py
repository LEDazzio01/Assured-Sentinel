import pickle
import logging
import os
from scorer import calculate_score

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("Commander")

class Commander:
    def __init__(self, calibration_file="calibration_data.pkl", default_threshold=0.15):
        """
        Initializes the Commander with a calibrated risk threshold.
        
        Args:
            calibration_file (str): Path to the pickle file containing q_hat.
            default_threshold (float): Fallback threshold if calibration file is missing.
        """
        self.threshold = self._load_threshold(calibration_file, default_threshold)
        logger.info(f"Commander ACTIVE. Risk Threshold (q_hat): {self.threshold}")

    def _load_threshold(self, filepath, default):
        """
        Loads the q_hat derived from Split Conformal Prediction calibration.
        """
        if os.path.exists(filepath):
            try:
                with open(filepath, 'rb') as f:
                    data = pickle.load(f)
                    return data['q_hat']
            except Exception as e:
                logger.error(f"Failed to load calibration data: {e}")
                return default
        else:
            # This warning is expected during the Day 4 build since we haven't run calibration yet
            logger.warning(f"Calibration file '{filepath}' not found. Using DEFAULT threshold: {default}")
            return default

    def verify(self, code_snippet):
        """
        The Logic Gate.
        
        Args:
            code_snippet (str): The Python code generated by the Analyst.
            
        Returns:
            dict: Decision object containing status, score, and reason.
        """
        # 1. Calculate Non-Conformity Score (The "Weirdness" of the code)
        score = calculate_score(code_snippet)
        
        # 2. Compare against Calibrated Threshold (The CP Guarantee)
        is_assured = score <= self.threshold
        
        decision = {
            "status": "PASS" if is_assured else "REJECT",
            "score": score,
            "threshold": self.threshold,
            "reason": ""
        }

        if is_assured:
            decision["reason"] = "Code meets assurance standards."
            logger.info(f"APPROVED (Score: {score} <= {self.threshold})")
        else:
            decision["reason"] = f"Security Score {score} exceeds threshold {self.threshold}."
            logger.warning(f"REJECTED (Score: {score} > {self.threshold})")
            
        return decision