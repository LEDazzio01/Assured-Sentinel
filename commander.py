import json
import pickle
import logging
import os
from scorer import calculate_score

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("Commander")

class Commander:
    def __init__(self, calibration_file="calibration_data.json", default_threshold=0.15):
        """
        Initializes the Commander with a calibrated risk threshold.
        
        Args:
            calibration_file (str): Path to the JSON file containing q_hat.
            default_threshold (float): Fallback threshold if calibration file is missing.
        """
        self.threshold = self._load_threshold(calibration_file, default_threshold)
        logger.info(f"Commander ACTIVE. Risk Threshold (q_hat): {self.threshold}")

    def _load_threshold(self, filepath, default):
        """
        Loads the q_hat derived from Split Conformal Prediction calibration.
        Supports both JSON (preferred) and legacy PKL formats.
        """
        # Try JSON first (preferred, safe format)
        json_path = filepath if filepath.endswith('.json') else filepath.replace('.pkl', '.json')
        if os.path.exists(json_path):
            try:
                with open(json_path, 'r') as f:
                    data = json.load(f)
                    logger.info(f"Loaded calibration from JSON (calibrated: {data.get('calibrated_at', 'unknown')})")
                    return data['q_hat']
            except Exception as e:
                logger.error(f"Failed to load JSON calibration data: {e}")
        
        # Fall back to legacy PKL (for backward compatibility)
        pkl_path = filepath if filepath.endswith('.pkl') else "calibration_data.pkl"
        if os.path.exists(pkl_path):
            try:
                with open(pkl_path, 'rb') as f:
                    data = pickle.load(f)
                    logger.warning("Loaded calibration from legacy PKL. Consider re-running calibration for JSON format.")
                    return data['q_hat']
            except Exception as e:
                logger.error(f"Failed to load PKL calibration data: {e}")
                return default
        
        # No calibration file found
        logger.warning(f"No calibration file found. Using DEFAULT threshold: {default}")
        return default

    def verify(self, code_snippet):
        """
        The Logic Gate.
        
        Args:
            code_snippet (str): The Python code generated by the Analyst.
            
        Returns:
            dict: Decision object containing status, score, and reason.
        """
        # 1. Calculate Non-Conformity Score (The "Weirdness" of the code)
        score = calculate_score(code_snippet)
        
        # 2. Compare against Calibrated Threshold (The CP Guarantee)
        is_assured = score <= self.threshold
        
        decision = {
            "status": "PASS" if is_assured else "REJECT",
            "score": score,
            "threshold": self.threshold,
            "reason": ""
        }

        if is_assured:
            decision["reason"] = "Code meets assurance standards."
            logger.info(f"APPROVED (Score: {score} <= {self.threshold})")
        else:
            decision["reason"] = f"Security Score {score} exceeds threshold {self.threshold}."
            logger.warning(f"REJECTED (Score: {score} > {self.threshold})")
            
        return decision